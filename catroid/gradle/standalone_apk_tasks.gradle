/*
 * Catroid: An on-device visual programming system for Android devices
 * Copyright (C) 2010-2017 The Catrobat Team
 * (<http://developer.catrobat.org/credits>)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * An additional term exception under section 7 of the GNU Affero
 * General Public License, version 3, is available at
 * http://developer.catrobat.org/license_additional_term
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import groovy.json.StringEscapeUtils
import groovy.xml.XmlUtil
import groovy.xml.StreamingMarkupBuilder
import java.nio.file.Paths
import java.util.zip.ZipFile

ext {
    id = "1" // TODO remove!

    assetsPath = "src/main/assets/"
    standaloneZipPath = assetsPath + "project.zip"
    standaloneTmpPath = assetsPath + "standalone/"

    manifestPath = "src/main/AndroidManifest.xml"
    resPath = "src/main/res/drawable-nodpi"
    googleServicesJsonPath = "google-services.json"

    buildStandaloneInfoTmpPath = "buildStandaloneInfoTmp"
    projectName = 'No Standalone Project'
    manifestAppName = '' // TODO make this happen
    projectId = 'No Starting Project'
    appZipFile = null
}

class StandalonePreparation
{
    private def ext
    private String downloadUrl
    private String projectPath
    private String assetsPath
    private File tempDir
    private File programZip
    private File zipOutDir

    StandalonePreparation(String id, def project) {
        this(id, "https://pocketcode.org/download/${id}.catrobat", project)
    }

    StandalonePreparation(String id, String downloadUrl, def project) {
        this.ext = project.ext
        this.ext.projectId = id
        this.downloadUrl = downloadUrl
        this.projectPath = project.projectDir.absolutePath
        def assetsPath = Paths.get(project.projectDir.absolutePath, this.ext.assetsPath)
        this.ext.appZipFile = new File("${assetsPath}/${ext.projectId}.zip") // TODO check if this works with new
    }

    void execute() {
        // TODO maybe do not extract things here but instead just
        // 1. download the zip
        // 2. determine the app id --> store in ext
        // 3. determine the app name --> store in ext
        // NOTE as a first step this could even be done without actually doing a standalone app!
        println "Preparing for the Standalone APP $ext.projectId"
        download()
        determineProjectName()
    }

    private void download() {
        println "downloading.... " + downloadUrl
        ext.appZipFile.withOutputStream {
            it << new URL(downloadUrl).content
        }
        println "downloaded to: " + ext.appZipFile.absolutePath
    }

    private void determineProjectName() {
        def zipFile = new ZipFile(ext.appZipFile)
        def codeXmlEntry = zipFile.getEntry('code.xml')
        String codeXmlContents = zipFile.getInputStream(codeXmlEntry).text
        codeXmlContents = codeXmlContents.replaceAll("&#x0;", "") // no \0 characters are allowed in xml
        def programNode = new XmlSlurper().parseText(codeXmlContents)
        String programName = programNode.header.programName.text()

        println "app #$ext.projectId has name '$programName'"
        // TODO try the sanitizing with failing crap programs

        // TODO cleanup file _after_ the APK was generated, i.e. add a new task that has correct dependencies and
        // does that

        ext.manifestAppName = escapeXml(programName)
        ext.projectName = escapeJava(programName)
    }

    private String escapeXml(String text) {
        XmlUtil.escapeXml(text)
    }

    private String escapeJava(String text) {
        StringEscapeUtils.escapeJava(text)
    }
}

// TODO this is not actually a task!!!
task standalonePreparation() {
    def crapPath = Paths.get(project.projectDir.absolutePath, project.ext.assetsPath)
    println "##### $crapPath"
    println("########## standlonePreparation $project.projectDir")
    /*
     * Configuration
     *
     * Do the downloading of the APP _before_ the configuration.
     * This is to ensure that the variables like the application name are
     * already present when the configuration step comes to the android extension.
     */
    if (project.hasProperty("download")) {
        new StandalonePreparation(project["suffix"], project["download"], project).execute()
        println "##### B1 $project.ext.projectName $project.ext.appZipFile"
    }

    doLast {
//        File zipOutDir = file(project.ext.standaloneTmpPath)
//        zipOutDir.mkdirs()

//        println "zipOutDir: " + zipOutDir.absolutePath

        // TODO this is most likely not needed!
//        copy {
//            from zipTree(project.ext.appZipFile)
//            into zipOutDir
//        }

        // TODO do we actually have to unpack this stuff or is it sufficient to provide the icon since the app
        // downloads it itself???
        println "buildStandalone task triggered"
        adaptManifest(file(project.ext.manifestPath), project.ext.manifestAppName)
        removeUnecessaryPermissions()
        adaptGoogleServices(file(project.ext.googleServicesJsonPath), project.ext.projectId)
        copyScreenshotAsIcon(new ZipFile(project.ext.appZipFile))
//        copyScreenshotAsIcon()

        // TODO where is the contents actually copied? especially since this is removed directly below here!
//        delete project.ext.standaloneTmpPath
    }
}

def adaptManifest(File manifest, String appName) {
    println "manifestFile: " + manifest.absolutePath
    def text = manifest.text
    text = text.replaceAll("@string/app_name", appName);
    text = text.replaceAll("@drawable/ic_launcher", "@drawable/icon");
    manifest.write(text)
}

def adaptGoogleServices(File googleServices, String projectId) {
    def text = googleServices.text

    // Clean up first to ensure that org.catrobat.catroid.abc does not become org.catrobat.abc.abc after two runs
    def oldName = 'org.catrobat.catroid'
    def newName = "org.catrobat.catroid.${projectId}"
    text = text.replaceAll(newName, oldName)

    // now change it
    text = text.replaceAll(oldName, newName)
    googleServices.write(text)
}

/*task buildStandalone() << {
    def id = 824; //debugging purpose only
    def downloadUrl = "";

    if (project.hasProperty("download")) {
        downloadUrl = project["download"]
        id = project["suffix"]
    } else {
        downloadUrl = "https://pocketcode.org/download/" + id + ".catrobat"
    }

    project.ext.id = id

    println "downloading.... " + downloadUrl

    project.ext.standaloneZipPath = project.ext.assetsPath + project.ext.id + ".zip"

    File programZip = file(project.ext.standaloneZipPath)
    println "programZip: " + programZip.absolutePath

    programZip.withOutputStream {
        it << new URL(downloadUrl).content
    }

    File zipOutDir = file(project.ext.standaloneTmpPath)
    zipOutDir.mkdirs()

    println "zipOutDir: " + zipOutDir.absolutePath

    copy {
        from zipTree(programZip)
        into zipOutDir
    }

    project.ext.projectName = getProjectName()

    println "buildStandalone task triggered"
    File manifestFile = file(project.ext.manifestPath)
    println "manifestFile: " + manifestFile.absolutePath
    def manifestText = manifestFile.text

    String projectName = getProjectName();
    projectName = projectName.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
            .replaceAll("\"", "&quot;").replaceAll("'", "&apos;");

    manifestText = manifestText.replaceAll("@string/app_name", projectName);
    manifestText = manifestText.replaceAll("@drawable/ic_launcher", "@drawable/icon");
    manifestFile.write(manifestText)

    removeUnecessaryPermissions()

    File googleServicesJsonFile = file(project.ext.googleServicesJsonPath)
    def googleServicesJsonText = googleServicesJsonFile.text

    googleServicesJsonText = googleServicesJsonText.replaceAll("org.catrobat.catroid", "org.catrobat.catroid." + getPackageNameSuffix())
    googleServicesJsonFile.write(googleServicesJsonText)

    File standaloneInfoTmpFile = file(project.ext.buildStandaloneInfoTmpPath)
    println "standaloneInfoTmpFile: " + standaloneInfoTmpFile.absolutePath
    standaloneInfoTmpFile.write(project.ext.id + "\n")
    standaloneInfoTmpFile.append(project.ext.projectName)

    copyScreenshotAsIcon()

    delete project.ext.standaloneTmpPath
}*/

task assembleDebugTest(dependsOn: ':assembleCatroidDebugTest') << {}
task commandlineAdbInstallDebug(dependsOn: ':commandlineAdbInstallCatroidDebug') << {}
task commandlineAdbInstallDebugTest(dependsOn: 'commandlineAdbInstallCatroidDebugTest') << {}

task testremoveIntentFilters() << {
    messUpIntentFilters()
}

ext.getProjectName = {
    File xmlFile = file(project.ext.standaloneTmpPath + "code.xml")
    File standaloneInfoTmpFile = file(project.ext.buildStandaloneInfoTmpPath)

    if (xmlFile.exists()) {
        String sanitizedXml = xmlFile.text.replaceAll("&#x0;", "")
        def programNode = new XmlSlurper().parseText(sanitizedXml)
        return programNode.header.programName.text()
    } else if (standaloneInfoTmpFile.exists()) {
        def lines = standaloneInfoTmpFile.readLines()
        assert 2 == lines.size()
        return lines[1]
    }

    return "Default Project"
}

ext.getPackageNameSuffix = {
    println ':getPackageNameSuffix'
    if (project.hasProperty("suffix")) {
        return project["suffix"]
    } else {
        //return "standalone"
        return "g" + getProgramId(false);
    }
}

def removeUnecessaryPermissions() {
    println "managing Permissions"
    File permissionsFile = file(project.ext.standaloneTmpPath + "permissions.txt")
    File manifestFile = file(project.ext.manifestPath);
    def manifestText = manifestFile.text;

    if(!permissionsFile.exists()) {
        println "no permissionTXT"
        return
    }
    def permissionsText = permissionsFile.text

    def manifestXml = new XmlSlurper().parseText(manifestText)

    def permissionsToRemove = []
    def featuresToRemove = []

    if((!permissionsText.contains("BLUETOOTH_LEGO_NXT")) && (!permissionsText.contains("BLUETOOTH_PHIRO_PRO"))){
        permissionsToRemove.add('android.permission.BLUETOOTH_ADMIN')
        permissionsToRemove.add('android.permission.BLUETOOTH')
        permissionsToRemove.add('android.permission.USE_CREDENTIALS')

        featuresToRemove.add('android.hardware.bluetooth')
    }

    if(!permissionsText.contains("ARDRONE_SUPPORT")){
        permissionsToRemove.add('android.permission.CHANGE_WIFI_MULTICAST_STATE')
        permissionsToRemove.add('android.permission.CHANGE_WIFI_STATE')
        permissionsToRemove.add('android.permission.ACCESS_WIFI_STATE')

        featuresToRemove.add('android.hardware.wifi')
    }

    if((!permissionsText.contains("CAMERA_FLASH")) && (!permissionsText.contains("FACE_DETECTION"))){
        permissionsToRemove.add('android.permission.CAMERA')

        featuresToRemove.add('android.hardware.camera')
    }

    if(!permissionsText.contains("VIBRATOR")){
        permissionsToRemove.add('android.permission.VIBRATE')
    }

    manifestXml."uses-permission".findAll {
        permissionsToRemove.indexOf(it."@android:name") != -1
    }*.replaceNode{}

    manifestXml."uses-feature".findAll {
        featuresToRemove.indexOf(it."@android:name") != -1
    }*.replaceNode{}

    manifestText = XmlUtil.serialize(new StreamingMarkupBuilder().bind{ mkp.yield manifestXml})

    manifestFile.write(manifestText)
}

def copyScreenshotAsIcon(ZipFile appZipFile) {
    def screenshotBytes = loadScreenshotBytes(appZipFile)
    if (!screenshotBytes) {
        println 'Could not find a screenshot'
        return
    }

    File icon = file("$project.ext.resPath/icon.png")
    print(icon)
    icon.setBytes(screenshotBytes)
}

def loadScreenshotBytes(ZipFile zip) {
    def pngMagicNumber = [-119, 80, 78, 71, 13, 10, 26, 10]
    def validNames = ['manual_screenshot.png', 'automatic_screenshot.png']
    def screenshots = zip.entries().grep { !it.directory }
                                   .grep { entry -> validNames.any { it == entry.name || entry.name.endsWith("/$it") } }
                                   .toSorted { validNames.indexOf(it.name) }

    for (def entry : screenshots) {
        def bytes = zip.getInputStream(entry).bytes
        if (bytes[0..7] == pngMagicNumber) {
            println "Found screenshot at '$entry.name'"
            return bytes
        }
    }

    return null
}

def messUpIntentFilters() {
    File manifestFile = file(project.ext.manifestPath);
    def manifestText = manifestFile.text

    String regex = "<intent-filter>\\n.+?<action android:name=\"android.intent.action.(VIEW|GET_CONTENT)(.|\\n)+?</intent-filter>"
    String noIntentManifest = manifestText.replaceAll(regex, "")
    manifestFile.write(noIntentManifest)
}
